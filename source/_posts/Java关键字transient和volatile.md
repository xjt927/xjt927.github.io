---
title: Java关键字transient和volatile
abbrlink: 9ac39d03
date: 2019-11-20 22:35:08
tags:
categories:
keywords:
---
# transient

词义：*短暂的*

首先说说“序列化”，把一个对象的表示转化为字节流的过程称为串行化（也称为序列化，serialization），从字节流中把对象重建出来称为反串行化（也称为为反序列化，deserialization）。
**transient为不应被串行化的数据提供了一个语言级的标记数据方法**。

`transient`是类型修饰符，只能用来修饰字段。在对象序列化的过程中，标记为`transient`的变量**不会被序列化**。

```
class Test {
	transient int a; // 不会被持久化
	int b; // 持久化
}
```
当类Test的实例对象被序列化（比如将Test类的实例对象 t 写入硬盘的文本文件t.txt中），变量 a 的内容不会被保存，变量 b 的内容则会被保存。

# volatile


词义：*易变的*
`volatile`也是变量修饰符，只能用来修饰变量。`volatile`修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
在此解释一下Java的内存机制：
Java使用一个主内存来保存变量当前值，而每个线程则有其独立的工作内存。线程访问变量的时候会将变量的值拷贝到自己的工作内存中，这样，当线程对自己工作内存中的变量进行操作之后，就造成了工作内存中的变量拷贝的值与主内存中的变量值不同。
Java语言规范中指出：**为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。**
这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。
而`volatile`关键字就是提示VM：**对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。**

对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。

典型的例子
```
for(int i=0; i<100000; i++);
```
这个语句用来测试空循环的速度的
但是编译器肯定要把它优化掉，根本就不执行
如果你写成

```
for(volatile int i=0; i<100000; i++);
```
它就会执行了


使用建议：在两个或者更多的线程访问的成员变量上使用`volatile`。当要访问的变量已在`synchronized`代码块中，或者为常量时，不必使用。由于使用`volatile`屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
---
title: 5.分布式理论：一致性协议2PC和3PC
abbrlink: 9awc665
date: 2020-07-10 10:14:56
tags: 分布式
categories: 分布式
keywords: 分布式,一致性
---
# 分布式理论：一致性协议2PC

## 什么是2PC

2PC （ Two-Phase Commit缩写）即两阶段提交协议，是将整个事务流程分为两个阶段，**准备阶段（Prepare phase）、提交阶段（commit phase）**，2是指两个阶段，**P是指准备阶段，C是指提交阶段**。



## 2PC的工作方式

P准备阶段可以理解为投票阶段。

C提交阶段可以理解为执行阶段。

我们将提议的节点称为协调者(coordinator)，其他参与决议节点称为参与者(participants, 或cohorts)。

### 简单理解：

阶段1

![mark](http://blog.xuejiangtao.com/blog/20200704/qLDf4kMFiKg1.png?imageslim)

阶段2

![mark](http://blog.xuejiangtao.com/blog/20200704/XoyN9eFj325B.png?imageslim)

阶段1投票阶段，协调者发起一个提议，分别询问各参与者是否可以执行。此时各参与者返回是否通过决议。

阶段2执行阶段，当阶段1的参与者全票通过决议后，则提交事务。有一个参与者不同意则中止事务。



### 深度理解：

![mark](http://blog.xuejiangtao.com/blog/20200704/dW7FLTge2kUn.png?imageslim)

1. 准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。 （**Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件**）

2. 提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。

   注意：必须在最后阶段释放锁资源。 



## 2PC优缺点

优点：

1. 原理简单，容易实现。

缺点：

1. 同步阻塞

   二阶段提交协议存在最明显也是最大的一个问题就是同步阻塞，在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，无法进行其他操作。这种同步阻塞极大的限制了分布式系统的性能。

2. 单点故障

   协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的是：其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。

3. 数据不一致

   假设当协调者向所有的参与者发送 commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有

   commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问题。

4. 过于保守

   如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提交协议没有设计较为完善的容错机制，任意一个节点失败都会导致整个事务的失败。

# 分布式理论：一致性协议3PC

​		三阶段提交（Three-phase commit），是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点。

- 引入超时机制。同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有`CanCommit`、`PreCommit`、`DoCommit`三个阶段。

## **CanCommit阶段**　

​		3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。

- **事务询问** 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。
- **响应反馈** 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No。

## **PreCommit阶段**

​	协调者在得到所有参与者的响应之后，会根据结果来执行2两个操作：执行事务预提交，或者中断事务。

​	假如所有参与反馈的都是Yes，那么就会执行事务预提交。

1)、假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。　　　　

- **发送预提交请求** 协调者向参与者发送PreCommit请求，并进入Prepared阶段。
- **事务预提交** 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
- **响应反馈** 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。

2)、假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。　　

- **发送中断请求** 协调者向所有参与者发送abort请求。
- **中断事务** 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。

## **doCommit阶段**

该阶段进行真正的事务提交，也可以分为以下两种情况。

**1)、执行提交**　　

- **发送提交请求** 协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。
- **事务提交** 参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。
- **响应反馈** 事务提交完之后，向协调者发送Ack响应。
- **完成事务** 协调者接收到所有参与者的ack响应之后，完成事务。

**2)、中断事务**

　　协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。

- **发送中断请求** 协调者向所有参与者发送abort请求。
- **事务回滚** 参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
- **反馈结果** 参与者完成事务回滚之后，向协调者发送ACK消息。
- **中断事务** 协调者接收到参与者反馈的ACK消息之后，执行事务的中断。



## 注意：一旦进入阶段三，可能会出现 2 种故障：

1. 协调者出现问题

2. 协调者和参与者之间的网络故障

如果出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，**继续进行事务提交**。

# **2PC和3PC的区别**

相对于2PC，3PC主要**解决的单点故障问题，并减少阻塞**，因为一旦参与者无法及时收到来自协调者的信息之后，他会**默认执行commit**。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，由于网络原因，协调者发送的abort响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。

1. 首先对于协调者和参与者都设置了超时机制（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到参与者的消息则默认失败）,主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。 

2. 通过**CanCommit**、**PreCommit**、**DoCommit**三个阶段的设计，相较于2PC而言，多设置了一个**缓冲阶段**保证了在最后提交阶段之前各参与节点的状态是一致的 。

3. PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。

**注意：3PC协议并没有完全解决数据不一致问题。**

